#pragma kernel CSAdvectLiquid

#define SOLID_NODE_TYPE 1
#define EMPTY_NODE_TYPE 0

#define NODE_VOL_IDX 0
#define NODE_TYPE_IDX 1
#define NODE_SETTLED_IDX 2

#define SETTLED_NODE 1
#define UNSETTLED_NODE 0

#define LIQUID_EPSILON 1e-6;

float liquidDensity;
float atmoPressure;
float maxGravityVel;
float maxPressureVel;
int maxPressureHeight;

float dt;

uint3 borderBack;   // Border at the front of the buffer (at least 1 unit on each axis)
uint3 borderFront;  // Border at the back of the buffer (at least 1 unit on each axis)
uint  size;         // Total size of the buffer on each side

int cellType(float3 cell) { return cell[NODE_TYPE_IDX]; }
bool isOutOfBounds(uint3 id) {
  return (id.x < borderFront.x || id.y < borderFront.y || id.z < borderFront.z ||
          id.x >= resolution-borderBack.x || id.y >= resolution-borderBack.y || id.z >= resolution-borderBack.z);
}




// Liquid Advection
RWTexture3D<float3> vel;       // Input buffer of the current velocities
RWTexture3D<float3> cellData;  // Input buffer of the liquid node/cell data
RWTexture3D<float3> advectVel; // Output buffer of the advected velocity

[numthreads(8,8,8)]
void CSAdvectLiquid(uint3 id : SV_DispatchThreadID) {
  float3 cell = cellData[id.xyz];
  if (isOutOfBounds(id) || cellType(cell) == SOLID_NODE_TYPE) { 
    advectVel[id.xyz] = float3(0,0,0);
    return;
  }

  float3 u = vel[id.xyz];
  float xx = clamp(id.x-dt*u.x, 0.5, )


}




