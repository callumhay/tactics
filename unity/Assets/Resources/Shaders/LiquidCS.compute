#pragma kernel CSAdvect
#pragma kernel CSApplyExternalForces
#pragma kernel CSCurl
#pragma kernel CSVorticityConfinementKernel
#pragma kernel CSDivergenceKernel
#pragma kernel CSPressureKernel
#pragma kernel CSProjectKernel
#pragma kernel CSCalculateFlowsKernel
#pragma kernel CSSumFlowsKernel
#pragma kernel CSAdjustNodeFlowsKernel
#pragma kernel CSFillDebugNodeData

#include "CommonCS.hlsl"
#include "NodeDefs.hlsl"

#define LIQUID_EPSILON 1e-6
#define MAX_PRESSURE_HEIGHT 5
#define FRICTION_AMT 15

float unitsPerNode;

float liquidDensity;
float atmoPressure;
float maxGravityVel;
float maxPressureVel;

float dt;

uint3 borderBack;   // Border at the front of the buffer (at least 1 unit on each axis)
uint3 borderFront;  // Border at the back of the buffer (at least 1 unit on each axis)
uint3 internalSize; // Internal size of the buffer (full size minus the borders)
uint  fullSize;     // Full size of the buffer on each side

void neighbourIndices(uint3 id, out uint3 idxL, out uint3 idxR, out uint3 idxB, out uint3 idxT, out uint3 idxD, out uint3 idxU) {
  uint3 xyzm1 = uint3(clampm1(id.x), clampm1(id.y), clampm1(id.z)); 
  uint3 xyzp1 = uint3(clampp1(id.x, fullSize-1), clampp1(id.y, fullSize-1), clampp1(id.y, fullSize-1));
  idxL = uint3(xyzm1.x, id.y, id.z); idxR = uint3(xyzp1.x, id.y, id.z);
  idxB = uint3(id.x, xyzm1.y, id.z); idxT = uint3(id.x, xyzp1.y, id.z);
  idxD = uint3(id.x, id.y, xyzm1.z); idxU = uint3(id.x, id.y, xyzp1.z);
}

uint idToIndex(uint3 id) {
	return id.x + id.y * fullSize + id.z * fullSize * fullSize;
}

// Buffers used throughout the kernels
RWTexture3D<float4> vel;       // Input buffer of the current velocities
RWTexture3D<float4> nodeData;  // Input buffer of the liquid node/cell data

bool isOutOfBounds(uint3 id) {
  return (id.x < borderFront.x || id.y < borderFront.y || id.z < borderFront.z ||
          id.x >= fullSize-borderBack.x || id.y >= fullSize-borderBack.y || id.z >= fullSize-borderBack.z);
}

// Liquid Advection *****************
RWTexture3D<float4> advectVel; // Output buffer of the advected velocity

[numthreads(8,8,8)]
void CSAdvect(uint3 id : SV_DispatchThreadID) {
  if (isOutOfBounds(id) || nodeType(nodeData[id.xyz]) == SOLID_NODE_TYPE) { 
    advectVel[id.xyz] = float4(0,0,0,0);
    return;
  }

  float3 u = vel[id.xyz].xyz;
  
  float xx = clamp(id.x-dt*u.x, borderFront.x-0.5, internalSize.x+0.5);
  float yy = clamp(id.y-dt*u.y, borderFront.y-0.5, internalSize.y+0.5);
  float zz = clamp(id.z-dt*u.z, borderFront.z-0.5, internalSize.z+0.5);

  uint3 ijk0 = uint3(floor(xx), floor(yy), floor(zz));
  uint3 ijk1 = ijk0 + uint3(1,1,1);

  float sx1 = xx-ijk0.x; float sx0 = 1.0-sx1;
  float sy1 = yy-ijk0.y; float sy0 = 1.0-sy1;
  float sz1 = zz-ijk0.z; float sz0 = 1.0-sz1;

  float3 vel000 = vel[ijk0.xyz].xyz;
  float3 vel010 = vel[uint3(ijk0.x, ijk1.y, ijk0.z)].xyz;
  float3 vel100 = vel[uint3(ijk1.x, ijk0.y, ijk0.z)].xyz;
  float3 vel110 = vel[uint3(ijk1.xy, ijk0.z)].xyz;
  float3 vel001 = vel[uint3(ijk0.xy, ijk1.z)].xyz;
  float3 vel011 = vel[uint3(ijk0.x, ijk1.y, ijk1.z)].xyz;
  float3 vel101 = vel[uint3(ijk1.x, ijk0.y, ijk1.z)].xyz;
  float3 vel111 = vel[ijk1.xyz].xyz;
  float4 result = float4(0,0,0,0);

  [unroll]
  for (int i = 0; i < 3; i++) {
    float v0 = sx0*(sy0*vel000[i] + sy1*vel010[i]) + sx1*(sy0*vel100[i] + sy1*vel110[i]);
    float v1 = sx0*(sy0*vel001[i] + sy1*vel011[i]) + sx1*(sy0*vel101[i] + sy1*vel111[i]);
    result[i] = sz0*v0 + sz1*v1;
  }

  advectVel[id.xyz] = result;
}

// Applying External Forces (e.g., Gravity, Hydrostatic Pressure) ****************
float gravityMagnitude;
//float dt;
//float unitsPerNode;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> nodeData;
RWTexture3D<float4> velApplExtForces; // Output of buffer for applying external forces

[numthreads(8,8,8)]
void CSApplyExternalForces(uint3 id : SV_DispatchThreadID) {

  float4 node = nodeData[id.xyz];
  float nodeVol = nodeLiquidVolume(node);
  float4 u = vel[id.xyz];

  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE || nodeVol < LIQUID_EPSILON) { 
    velApplExtForces[id.xyz] = u;
    return;
  }

  float4 result = float4(u.xyz, 0);  
  float4 bottomNode   = nodeData[uint3(id.x,id.y-1,id.z)];
  int bottomNodeType  = nodeType(bottomNode);
  float bottomNodeVol = nodeLiquidVolume(bottomNode);

  // Apply Gravity
  result.y = clamp(result.y - gravityMagnitude*dt, -maxGravityVel, maxGravityVel);

  // Determine the hydrostatic pressure = density*gravity*(mass of the fluid above)
  // How much pressure is pressing down on this cell (up to the max pressure height)?
  float liquidVolAboveCell = 0.0;
  int pressureHeightIdx = min(borderFront.y+internalSize.y-1, id.y+1+MAX_PRESSURE_HEIGHT);
  [unroll(MAX_PRESSURE_HEIGHT)]
  for (int y = id.y+1; y < pressureHeightIdx; y++) {
    float4 topNode   = nodeData[uint3(id.x, y, id.z)];
    int topNodeType  = nodeType(topNode);
    float topNodeVol = nodeLiquidVolume(topNode);

    if (topNodeType == SOLID_NODE_TYPE || topNodeVol < LIQUID_EPSILON) { break; }
    liquidVolAboveCell += topNodeVol;
  }

  float liquidMassAboveNode = liquidDensity * liquidVolAboveCell;
  float hsForce = atmoPressure * (unitsPerNode * unitsPerNode) + liquidMassAboveNode * gravityMagnitude;
  float dHSVel = hsForce*dt;

  float4 nodeL = nodeData[uint3(id.x-1, id.y, id.z)];
  float4 nodeR = nodeData[uint3(id.x+1, id.y, id.z)];
  float4 nodeD = nodeData[uint3(id.xy, id.z-1)];
  float4 nodeU = nodeData[uint3(id.xy, id.z+1)];
  
  // Apply hydrostatic pressure
  float totalVelX = 0.0; float totalVelZ = 0.0;
  if (bottomNodeType == SOLID_NODE_TYPE || bottomNodeVol >= nodeVol) {
    totalVelX -= (nodeType(nodeL) == EMPTY_NODE_TYPE && nodeLiquidVolume(nodeL) < nodeVol) ? dHSVel : 0;
    totalVelX += (nodeType(nodeR) == EMPTY_NODE_TYPE && nodeLiquidVolume(nodeR) < nodeVol) ? dHSVel : 0;
    totalVelZ -= (nodeType(nodeD) == EMPTY_NODE_TYPE && nodeLiquidVolume(nodeD) < nodeVol) ? dHSVel : 0;
    totalVelZ += (nodeType(nodeU) == EMPTY_NODE_TYPE && nodeLiquidVolume(nodeU) < nodeVol) ? dHSVel : 0;
  }
  result.x = clamp(result.x + totalVelX, -maxPressureVel, maxPressureVel);
  result.z = clamp(result.z + totalVelZ, -maxPressureVel, maxPressureVel);

  // Friction hack
  float frictionVelX = dt*FRICTION_AMT;
  float frictionVelZ = dt*FRICTION_AMT;
  result.x = result.x < 0 ? min(0, result.x + frictionVelX) : max(0, result.x - frictionVelX);
  result.z = result.z < 0 ? min(0, result.z + frictionVelZ) : max(0, result.z - frictionVelZ);

  velApplExtForces[id.xyz] = result;
}

// Vorticity Confinement Kernels *****************

//uint fullSize;
//float unitsPerNode;
//RWTexture3D<float4> vel;
RWTexture3D<float4> curl; // Output of CSCurl
RWTexture3D<float> curlLength; // Output of CSCurl

[numthreads(8,8,8)]
void CSCurl(uint3 id : SV_DispatchThreadID) {

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float3 L = vel[idxL].xyz; float3 R = vel[idxR].xyz;
  float3 B = vel[idxB].xyz; float3 T = vel[idxT].xyz;
  float3 D = vel[idxD].xyz; float3 U = vel[idxU].xyz;

  float unitsPerNodeTimes2 = 2.0*unitsPerNode;
  float4 curlVec = float4(
    ((T[2] - B[2]) - (U[1] - D[1])) / unitsPerNodeTimes2,
    ((U[0] - D[0]) - (R[2] - L[2])) / unitsPerNodeTimes2,
    ((R[1] - L[1]) - (T[0] - B[0])) / unitsPerNodeTimes2, 0
  );

  curl[id.xyz] = curlVec;
  curlLength[id.xyz] = length(curlVec);
}

float dtVC;
//float unitsPerNode;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> curl;
//RWTexture3D<float> curlLength;
RWTexture3D<float4> vcVel; // Output of CSVorticityConfinementKernel

[numthreads(8,8,8)]
void CSVorticityConfinementKernel(uint3 id : SV_DispatchThreadID) {

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float4 omega = curl[id.xyz];
  float omegaL = curlLength[idxL]; float omegaR = curlLength[idxR];
  float omegaB = curlLength[idxB]; float omegaT = curlLength[idxT];
  float omegaD = curlLength[idxD]; float omegaU = curlLength[idxU];

  float unitsPerNodeTimes2 = 2.0*unitsPerNode;
  float3 eta = float3(
    (omegaR - omegaL) / unitsPerNodeTimes2,
    (omegaT - omegaB) / unitsPerNodeTimes2, 
    (omegaU - omegaD) / unitsPerNodeTimes2
  );
  float etaLen = length(eta) + 1e-10;
  eta /= etaLen;
  float3 u = vel[id.xyz].xyz;

  vcVel[id.xyz] = float4(
    u[0] + dtVC * (eta[0]*omega[2] - eta[2]*omega[1]),
    u[1] + dtVC * (eta[2]*omega[0] - eta[0]*omega[2]),
    u[2] + dtVC * (eta[0]*omega[1] - eta[1]*omega[0]), 0
  );
}

// Divergence *****************
//uint fullSize;
//uint3 internalSize;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> nodeData;
RWTexture3D<float> pressure; // Output: We clear the initial pressure buffer while we calculate the divergence
RWTexture3D<float> divergence; // Output of CSDivergenceKernel


[numthreads(8,8,8)]
void CSDivergenceKernel(uint3 id : SV_DispatchThreadID) {
  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float4 nL = nodeData[idxL]; float4 nR = nodeData[idxR];
  float4 nB = nodeData[idxB]; float4 nT = nodeData[idxT];
  float4 nD = nodeData[idxD]; float4 nU = nodeData[idxU];

  float3 noVel = float3(0,0,0);
  float3 fieldL = (nodeType(nL) == SOLID_NODE_TYPE) ? noVel : vel[idxL].xyz;
  float3 fieldR = (nodeType(nR) == SOLID_NODE_TYPE) ? noVel : vel[idxR].xyz;
  float3 fieldB = (nodeType(nB) == SOLID_NODE_TYPE) ? noVel : vel[idxB].xyz;
  float3 fieldT = (nodeType(nT) == SOLID_NODE_TYPE) ? noVel : vel[idxT].xyz;
  float3 fieldD = (nodeType(nD) == SOLID_NODE_TYPE) ? noVel : vel[idxD].xyz;
  float3 fieldU = (nodeType(nU) == SOLID_NODE_TYPE) ? noVel : vel[idxU].xyz;

  divergence[id.xyz] = ((fieldR[0]-fieldL[0]) + (fieldT[1]-fieldB[1]) + (fieldU[2]-fieldD[2])) / (float)(internalSize.x+internalSize.y+internalSize.z);
  pressure[id.xyz] = 0.0;
}

// Pressure / Jacobian *****************
//RWTexture3D<float4> nodeData;
//RWTexture3D<float> divergence; 
RWTexture3D<float> inputPressure;
RWTexture3D<float> outputPressure; // Output of CSPressureKernel

[numthreads(8,8,8)]
void CSPressureKernel(uint3 id : SV_DispatchThreadID) {
  float pC = inputPressure[id.xyz];
  float4 node = nodeData[id.xyz];
  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE) { outputPressure[id.xyz] = pC; return; }
  if (nodeLiquidVolume(node) < LIQUID_EPSILON) { outputPressure[id.xyz] = 0.0; return; }

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float4 nL = nodeData[idxL]; float4 nR = nodeData[idxR];
  float4 nB = nodeData[idxB]; float4 nT = nodeData[idxT];
  float4 nD = nodeData[idxD]; float4 nU = nodeData[idxU];

  float bC = divergence[id.xyz]; // Contains the 'divergence' calculated previously

  float pL = (nodeType(nL) == SOLID_NODE_TYPE) ? pC : inputPressure[idxL];
  float pR = (nodeType(nR) == SOLID_NODE_TYPE) ? pC : inputPressure[idxR];
  float pB = (nodeType(nB) == SOLID_NODE_TYPE) ? pC : inputPressure[idxB];
  float pT = (nodeType(nT) == SOLID_NODE_TYPE) ? pC : inputPressure[idxT];
  float pD = (nodeType(nD) == SOLID_NODE_TYPE) ? pC : inputPressure[idxD];
  float pU = (nodeType(nU) == SOLID_NODE_TYPE) ? pC : inputPressure[idxU];

  outputPressure[id.xyz] = (pL + pR + pB + pT + pU + pD - bC) / 6.0;
}

// Project Velocity *****************
//uint3 internalSize;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> nodeData;
//RWTexture3D<float> pressure;
RWTexture3D<float4> projectedVel; // Output of CSProjectKernel

[numthreads(8,8,8)]
void CSProjectKernel(uint3 id : SV_DispatchThreadID) {
  float4 node = nodeData[id.xyz];
  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE) { projectedVel[id.xyz] = float4(0,0,0,0); return; }

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float4 nL = nodeData[idxL]; float4 nR = nodeData[idxR];
  float4 nB = nodeData[idxB]; float4 nT = nodeData[idxT];
  float4 nD = nodeData[idxD]; float4 nU = nodeData[idxU];

  float3 u = vel[id.xyz].xyz;
  float pC = pressure[id.xyz];
  float pL = pressure[idxL]; float pR = pressure[idxR];
  float pB = pressure[idxB]; float pT = pressure[idxT];
  float pD = pressure[idxD]; float pU = pressure[idxU];

  // NOTE: This requires augmentation if the boundaries have velocity!
  float3 vMaskPos = float3(1,1,1);
  float3 vMaskNeg = float3(1,1,1);
  if (nodeType(nL) == SOLID_NODE_TYPE || nodeSettled(nL) == SETTLED_NODE) { pL = pC; vMaskNeg[0] = 0; }
  if (nodeType(nR) == SOLID_NODE_TYPE || nodeSettled(nR) == SETTLED_NODE) { pR = pC; vMaskPos[0] = 0; }
  if (nodeType(nB) == SOLID_NODE_TYPE || nodeSettled(nB) == SETTLED_NODE) { pB = pC; vMaskNeg[1] = 0; }
  if (nodeType(nT) == SOLID_NODE_TYPE || nodeSettled(nT) == SETTLED_NODE) { pT = pC; vMaskPos[1] = 0; }
  if (nodeType(nD) == SOLID_NODE_TYPE || nodeSettled(nD) == SETTLED_NODE) { pD = pC; vMaskNeg[2] = 0; }
  if (nodeType(nU) == SOLID_NODE_TYPE || nodeSettled(nU) == SETTLED_NODE) { pU = pC; vMaskPos[2] = 0; }

  float sizeSum = internalSize.x+internalSize.y+internalSize.z;
  float4 result = float4(u[0] - (pR-pL) / sizeSum, u[1] - (pT-pB) / sizeSum, u[2] - (pU-pD) / sizeSum, 0);
  result[0] = min(result[0]*vMaskPos[0], max(result[0]*vMaskNeg[0], result[0]));
  result[1] = min(result[1]*vMaskPos[1], max(result[1]*vMaskNeg[1], result[1]));
  result[2] = min(result[2]*vMaskPos[2], max(result[2]*vMaskNeg[2], result[2]));
  projectedVel[id.xyz] = result;
}

// Calculating flows in/out of nodes *****************
//float unitsPerNode;
//uint fullSize;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> nodeData;
struct NodeFlowInfo {
  float flowL; float flowR;
  float flowB; float flowT;
  float flowD; float flowU;
};
RWStructuredBuffer<NodeFlowInfo> flows; // Output from CSCalculateFlowsKernel

[numthreads(8,8,8)]
void CSCalculateFlowsKernel(uint3 id : SV_DispatchThreadID) {
  NodeFlowInfo result; 
  result.flowL = result.flowR = result.flowB = result.flowT = result.flowD = result.flowU = 0.0;
  uint flowsIdx = idToIndex(id);

  float4 node = nodeData[id.xyz];
  float liquidVol = nodeLiquidVolume(node);
  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE || liquidVol == 0 || nodeSettled(node) == SETTLED_NODE) {
    flows[flowsIdx] = result;
    return;
  }
  
  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float4 nL = nodeData[idxL]; float4 nR = nodeData[idxR];
  float4 nB = nodeData[idxB]; float4 nT = nodeData[idxT];
  float4 nD = nodeData[idxD]; float4 nU = nodeData[idxU];

  float liquidVolL = nodeLiquidVolume(nL); float liquidVolR = nodeLiquidVolume(nR);
  float liquidVolB = nodeLiquidVolume(nB); float liquidVolT = nodeLiquidVolume(nT);
  float liquidVolD = nodeLiquidVolume(nD); float liquidVolU = nodeLiquidVolume(nU);

  int typeL = nodeType(nL); int typeR = nodeType(nR);
  int typeB = nodeType(nB); int typeT = nodeType(nT);
  int typeD = nodeType(nD); int typeU = nodeType(nU);

  float3 u = vel[id.xyz].xyz;

  // Calculate the absolute cross-section flows
  float unitArea = unitsPerNode * unitsPerNode;
  float3 absCSFlowLBD = abs(min(float3(0,0,0),u) * unitArea);
  float3 absCSFlowRTU = abs(max(float3(0,0,0),u) * unitArea);

  float unitVolume = unitArea * unitsPerNode;
  float3 flowToLBD = clamp(dt * unitVolume * absCSFlowLBD, 0, liquidVol);
  float3 flowToRTU = clamp(dt * unitVolume * absCSFlowRTU, 0, liquidVol);
  flowToRTU.y = clamp((liquidVol-liquidVolT) * absCSFlowRTU.y * dt, 0, liquidVol); // Yup, this is a hack, without it the liquid will not settle evenly / will disperse into the air.

  float3 maskLBD = float3(1,1,1); float3 maskRTU = float3(1,1,1);
  
  // Can we flow left?
  if (liquidVolL >= unitVolume || liquidVolL >= liquidVol ||  typeL == SOLID_NODE_TYPE ||  (typeB == EMPTY_NODE_TYPE && liquidVolB < liquidVol)) {
    // No flow leftward - redivert the flow to the other 3 possible directions on the xz plane
    float flowToLDiv = flowToLBD.x/3.0; 
    flowToRTU.x += flowToLDiv;
    flowToRTU.z += flowToLDiv;
    flowToLBD.z += flowToLDiv;
    maskLBD.x = 0;
  }
  // Can we flow right?
  if (liquidVolR >= unitVolume || liquidVolR >= liquidVol ||  typeR == SOLID_NODE_TYPE ||  (typeB == EMPTY_NODE_TYPE && liquidVolB < liquidVol)) {
    // No flow rightward - redivert the flow to the other 3 possible directions on the xz plane
    float flowToRDiv = flowToRTU.x/3.0; 
    flowToLBD.x += flowToRDiv;
    flowToRTU.z += flowToRDiv;
    flowToLBD.z += flowToRDiv;
    maskRTU.x = 0;
  }
  
  // Can we flow down?
  if (liquidVolB >= unitVolume || typeB == SOLID_NODE_TYPE) { maskLBD.y = 0; }
  // Can we flow up?
  if (liquidVolT >= liquidVol || typeT == SOLID_NODE_TYPE) { maskRTU.y = 0; }

  // Can we flow back?
  if (liquidVolD >= unitVolume || liquidVolD >= liquidVol || typeD == SOLID_NODE_TYPE || (typeB == EMPTY_NODE_TYPE && liquidVolB < liquidVol)) {
    // No flow backward - redivert the flow to the other 3 possible directions on the xz plane
    float flowToDDiv = flowToLBD.z/3.0; 
    flowToLBD.x += flowToDDiv;
    flowToRTU.x += flowToDDiv;
    flowToRTU.z += flowToDDiv;
    maskLBD.z = 0;
  }
  // Can we flow forward?
  if (liquidVolU >= unitVolume || liquidVolU >= liquidVol || typeU == SOLID_NODE_TYPE || (typeB == EMPTY_NODE_TYPE && liquidVolB < liquidVol)) {
    // No flow forward
    float flowToUDiv = flowToRTU.z/3.0; 
    flowToLBD.x += flowToUDiv;
    flowToRTU.x += flowToUDiv;
    flowToLBD.z += flowToUDiv;
    maskRTU.z = 0;
  }

  flowToLBD *= maskLBD; flowToRTU *= maskRTU;

  float totalFlow = flowToLBD.x + flowToLBD.y + flowToLBD.z + flowToRTU.x + flowToRTU.y + flowToRTU.z + 1e-10;
  result.flowL = min(max(0.5*(liquidVol-liquidVolL),0), min(liquidVol*(flowToLBD.x/totalFlow), flowToLBD.x));
  result.flowR = min(max(0.5*(liquidVol-liquidVolR),0), min(liquidVol*(flowToRTU.x/totalFlow), flowToRTU.x));
  result.flowB = min(0.5*(liquidVol+liquidVolB),        min(liquidVol*(flowToLBD.y/totalFlow), flowToLBD.y));
  result.flowT = min(max(0.5*(liquidVol-liquidVolT),0), min(liquidVol*(flowToRTU.y/totalFlow), flowToRTU.y));
  result.flowD = min(max(0.5*(liquidVol-liquidVolD),0), min(liquidVol*(flowToLBD.z/totalFlow), flowToLBD.z));
  result.flowU = min(max(0.5*(liquidVol-liquidVolU),0), min(liquidVol*(flowToRTU.z/totalFlow), flowToRTU.z));

  flows[flowsIdx] = result;
}

//RWStructuredBuffer<NodeFlowInfo> flows;
RWTexture3D<float> summedFlows; // Output of CSSumFlowsKernel
[numthreads(8,8,8)]
void CSSumFlowsKernel(uint3 id : SV_DispatchThreadID) {

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  NodeFlowInfo flowsC = flows[idToIndex(id)];
  NodeFlowInfo flowsL = flows[idToIndex(idxL)]; NodeFlowInfo flowsR = flows[idToIndex(idxR)];
  NodeFlowInfo flowsB = flows[idToIndex(idxB)]; NodeFlowInfo flowsT = flows[idToIndex(idxT)];
  NodeFlowInfo flowsD = flows[idToIndex(idxD)]; NodeFlowInfo flowsU = flows[idToIndex(idxU)];

  // The total volume change in this cell is equal to all the incoming flows
  // from neighbour cells minus the total outward flow from the current cell
  summedFlows[id.xyz] = (flowsL.flowR + flowsR.flowL + flowsB.flowT + flowsT.flowB + flowsD.flowU + flowsU.flowD) -
    (flowsC.flowR + flowsC.flowL + flowsC.flowB + flowsC.flowT + flowsC.flowD + flowsC.flowU);
}

// Adjust the node liquid volumes based on the final tabulation of all flows *****************
//RWTexture3D<float> summedFlows;
//RWTexture3D<float4> nodeData; // Output of CSAdjustNodeFlowsKernel
[numthreads(8,8,8)]
void CSAdjustNodeFlowsKernel(uint3 id : SV_DispatchThreadID) {
  float4 node = nodeData[id.xyz];
  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE) { return; } // Don't do anything if it's not a liquid node

  uint3 idxL, idxR, idxB, idxT, idxD, idxU;
  neighbourIndices(id, idxL, idxR, idxB, idxT, idxD, idxU);

  float sC = summedFlows[id.xyz];
  float sL = summedFlows[idxL]; float sR = summedFlows[idxR];
  float sB = summedFlows[idxB]; float sT = summedFlows[idxT];
  float sD = summedFlows[idxD]; float sU = summedFlows[idxU];

  float liquidVol = nodeLiquidVolume(node);
  float finalVol = (liquidVol + sC);
  node[NODE_VOL_IDX] = abs(finalVol) < LIQUID_EPSILON ? 0 : finalVol;

  // Unsettle the node if there are any changes in the neighbour cell flows
  if (abs(sL) >= LIQUID_EPSILON || abs(sR) >= LIQUID_EPSILON || 
      abs(sB) >= LIQUID_EPSILON || abs(sT) >= LIQUID_EPSILON ||
      abs(sD) >= LIQUID_EPSILON || abs(sU) >= LIQUID_EPSILON) {
    node[NODE_SETTLED_IDX] = UNSETTLED_NODE;
  }
  else {
    // If there's no change in the flow of the node then it becomes settled
    float unitVolume = unitsPerNode * unitsPerNode * unitsPerNode;
    node[NODE_SETTLED_IDX] = (abs(sC) < LIQUID_EPSILON && abs(liquidVol) < LIQUID_EPSILON) ||
      abs(liquidVol-unitVolume) < LIQUID_EPSILON ? SETTLED_NODE : UNSETTLED_NODE;
  }

  nodeData[id.xyz] = node;
}

// DEBUG STUFF *******************
//RWTexture3D<float4> nodeData; // Output of CSFillDebugNodeData
[numthreads(8,8,8)]
void CSFillDebugNodeData(uint3 id : SV_DispatchThreadID) {

  if (isOutOfBounds(id)) {
    nodeData[id.xyz] = buildNode(SOLID_NODE_TYPE, 0.0, SETTLED_NODE);
    return;
  }

  float volume = id.y > fullSize/2 ? 1.0 : 0.0;
  nodeData[id.xyz] = float4(volume, 0, 0, 1);//buildNode(EMPTY_NODE_TYPE, volume, UNSETTLED_NODE);

}