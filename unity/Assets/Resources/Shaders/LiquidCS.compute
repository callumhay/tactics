#pragma kernel CSAdvect

#define SOLID_NODE_TYPE 1
#define EMPTY_NODE_TYPE 0

#define NODE_VOL_IDX 0
#define NODE_TYPE_IDX 1
#define NODE_SETTLED_IDX 2

#define SETTLED_NODE 1
#define UNSETTLED_NODE 0

#define LIQUID_EPSILON 1e-6;

float liquidDensity;
float atmoPressure;
float maxGravityVel;
float maxPressureVel;
int maxPressureHeight;

float dt;

uint3 borderBack;   // Border at the front of the buffer (at least 1 unit on each axis)
uint3 borderFront;  // Border at the back of the buffer (at least 1 unit on each axis)
uint  fullSize;     // Full size of the buffer on each side
uint3 internalSize; // Internal size of the buffer (full size minus the borders)

int cellType(float3 cell) { return cell[NODE_TYPE_IDX]; }
bool isOutOfBounds(uint3 id) {
  return (id.x < borderFront.x || id.y < borderFront.y || id.z < borderFront.z ||
          id.x >= fullSize-borderBack.x || id.y >= fullSize-borderBack.y || id.z >= fullSize-borderBack.z);
}

// Liquid Advection
RWTexture3D<float3> vel;       // Input buffer of the current velocities
RWTexture3D<float3> cellData;  // Input buffer of the liquid node/cell data
RWTexture3D<float3> advectVel; // Output buffer of the advected velocity

[numthreads(8,8,8)]
void CSAdvect(uint3 id : SV_DispatchThreadID) {
  float3 cell = cellData[id.xyz];
  if (isOutOfBounds(id) || cellType(cell) == SOLID_NODE_TYPE) { 
    advectVel[id.xyz] = float3(0,0,0);
    return;
  }

  float3 u = vel[id.xyz];
  
  float xx = clamp(id.x-dt*u.x, borderFront.x-0.5, internalSize.x+0.5);
  float yy = clamp(id.y-dt*u.y, borderFront.y-0.5, internalSize.y+0.5);
  float zz = clamp(id.z-dt*u.z, borderFront.z-0.5, internalSize.z+0.5);

  uint3 ijk0 = uint3(floor(xx), floor(yy), floor(zz));
  uint3 ijk1 = ijk0 + uint3(1,1,1);

  float sx1 = xx-ijk0.x; float sx0 = 1.0-sx1;
  float sy1 = yy-ijk0.y; float sy0 = 1.0-sy1;
  float sz1 = zz-ijk0.z; float sz0 = 1.0-sz1;

  float3 vel000 = vel[ijk0.xyz];
  float3 vel010 = vel[uint3(ijk0.x, ijk1.y, ijk0.z)];
  float3 vel100 = vel[uint3(ijk1.x, ijk0.y, ijk0.z)];
  float3 vel110 = vel[uint3(ijk1.xy, ijk0.z)];
  float3 vel001 = vel[uint3(ijk0.xy, ijk1.z)];
  float3 vel011 = vel[uint3(ijk0.x, ijk1.y, ijk1.z)];
  float3 vel101 = vel[uint3(ijk1.x, ijk0.y, ijk1.z)];
  float3 vel111 = vel[ijk1.xyz];
  float3 result = float3(0,0,0);

  [unroll]
  for (int i = 0; i < 3; i++) {
    float v0 = sx0*(sy0*vel000[i] + sy1*vel010[i]) + sx1*(sy0*vel100[i] + sy1*vel110[i]);
    float v1 = sx0*(sy0*vel001[i] + sy1*vel011[i]) + sx1*(sy0*vel101[i] + sy1*vel111[i]);
    result[i] = sz0*v0 + sz1*v1;
  }

  advectVel[id.xyz] = result;
}




