#pragma kernel CSAdvect
#pragma kernel CSApplyExternalForces
#pragma kernel CSCurl
#pragma kernel CSVorticityConfinementKernel

#include "CommonCS.hlsl"

#define SOLID_NODE_TYPE 1
#define EMPTY_NODE_TYPE 0

#define NODE_VOL_IDX 0
#define NODE_TYPE_IDX 1
#define NODE_SETTLED_IDX 2

#define SETTLED_NODE 1
#define UNSETTLED_NODE 0

#define LIQUID_EPSILON 1e-6
#define MAX_PRESSURE_HEIGHT 5
#define FRICTION_AMT 15

float unitsPerNode;

float liquidDensity;
float atmoPressure;
float maxGravityVel;
float maxPressureVel;

float dt;

uint3 borderBack;   // Border at the front of the buffer (at least 1 unit on each axis)
uint3 borderFront;  // Border at the back of the buffer (at least 1 unit on each axis)
uint3 internalSize; // Internal size of the buffer (full size minus the borders)
uint  fullSize;     // Full size of the buffer on each side

// Buffers used throughout the kernels
RWTexture3D<float4> vel;       // Input buffer of the current velocities
RWTexture3D<float4> nodeData;  // Input buffer of the liquid node/cell data


int nodeType(float4 node) { return (int)node[NODE_TYPE_IDX]; }
float nodeVolume(float4 node) { return node[NODE_VOL_IDX]; }

bool isOutOfBounds(uint3 id) {
  return (id.x < borderFront.x || id.y < borderFront.y || id.z < borderFront.z ||
          id.x >= fullSize-borderBack.x || id.y >= fullSize-borderBack.y || id.z >= fullSize-borderBack.z);
}

// Liquid Advection *****************
RWTexture3D<float4> advectVel; // Output buffer of the advected velocity

[numthreads(8,8,8)]
void CSAdvect(uint3 id : SV_DispatchThreadID) {
  if (isOutOfBounds(id) || nodeType(nodeData[id.xyz]) == SOLID_NODE_TYPE) { 
    advectVel[id.xyz] = float4(0,0,0,0);
    return;
  }

  float3 u = vel[id.xyz].xyz;
  
  float xx = clamp(id.x-dt*u.x, borderFront.x-0.5, internalSize.x+0.5);
  float yy = clamp(id.y-dt*u.y, borderFront.y-0.5, internalSize.y+0.5);
  float zz = clamp(id.z-dt*u.z, borderFront.z-0.5, internalSize.z+0.5);

  uint3 ijk0 = uint3(floor(xx), floor(yy), floor(zz));
  uint3 ijk1 = ijk0 + uint3(1,1,1);

  float sx1 = xx-ijk0.x; float sx0 = 1.0-sx1;
  float sy1 = yy-ijk0.y; float sy0 = 1.0-sy1;
  float sz1 = zz-ijk0.z; float sz0 = 1.0-sz1;

  float3 vel000 = vel[ijk0.xyz].xyz;
  float3 vel010 = vel[uint3(ijk0.x, ijk1.y, ijk0.z)].xyz;
  float3 vel100 = vel[uint3(ijk1.x, ijk0.y, ijk0.z)].xyz;
  float3 vel110 = vel[uint3(ijk1.xy, ijk0.z)].xyz;
  float3 vel001 = vel[uint3(ijk0.xy, ijk1.z)].xyz;
  float3 vel011 = vel[uint3(ijk0.x, ijk1.y, ijk1.z)].xyz;
  float3 vel101 = vel[uint3(ijk1.x, ijk0.y, ijk1.z)].xyz;
  float3 vel111 = vel[ijk1.xyz].xyz;
  float4 result = float4(0,0,0,0);

  [unroll]
  for (int i = 0; i < 3; i++) {
    float v0 = sx0*(sy0*vel000[i] + sy1*vel010[i]) + sx1*(sy0*vel100[i] + sy1*vel110[i]);
    float v1 = sx0*(sy0*vel001[i] + sy1*vel011[i]) + sx1*(sy0*vel101[i] + sy1*vel111[i]);
    result[i] = sz0*v0 + sz1*v1;
  }

  advectVel[id.xyz] = result;
}

// Applying External Forces (e.g., Gravity, Hydrostatic Pressure) ****************
float gravityMagnitude;
//float dt;
//float unitsPerNode;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> nodeData;
RWTexture3D<float4> velApplExtForces; // Output of buffer for applying external forces

[numthreads(8,8,8)]
void CSApplyExternalForces(uint3 id : SV_DispatchThreadID) {

  float4 node = nodeData[id.xyz];
  float nodeVol = nodeVolume(node);
  float4 u = vel[id.xyz];

  if (isOutOfBounds(id) || nodeType(node) == SOLID_NODE_TYPE || nodeVol < LIQUID_EPSILON) { 
    velApplExtForces[id.xyz] = u;
    return;
  }

  float4 result = float4(u.xyz, 0);  
  float4 bottomNode   = nodeData[uint3(id.x,id.y-1,id.z)];
  int bottomNodeType  = nodeType(bottomNode);
  float bottomNodeVol = nodeVolume(bottomNode);

  // Apply Gravity
  result.y = clamp(result.y - gravityMagnitude*dt, -maxGravityVel, maxGravityVel);

  // Determine the hydrostatic pressure = density*gravity*(mass of the fluid above)
  // How much pressure is pressing down on this cell (up to the max pressure height)?
  float liquidVolAboveCell = 0.0;
  int pressureHeightIdx = min(borderFront.y+internalSize.y-1, id.y+1+MAX_PRESSURE_HEIGHT);
  [unroll(MAX_PRESSURE_HEIGHT)]
  for (int y = id.y+1; y < pressureHeightIdx; y++) {
    float4 topNode   = nodeData[uint3(id.x, y, id.z)];
    int topNodeType  = nodeType(topNode);
    float topNodeVol = nodeVolume(topNode);

    if (topNodeType == SOLID_NODE_TYPE || topNodeVol < LIQUID_EPSILON) { break; }
    liquidVolAboveCell += topNodeVol;
  }

  float liquidMassAboveNode = liquidDensity * liquidVolAboveCell;
  float hsForce = atmoPressure * (unitsPerNode * unitsPerNode) + liquidMassAboveNode * gravityMagnitude;
  float dHSVel = hsForce*dt;

  float4 nodeL = nodeData[uint3(id.x-1, id.y, id.z)];
  float4 nodeR = nodeData[uint3(id.x+1, id.y, id.z)];
  float4 nodeD = nodeData[uint3(id.xy, id.z-1)];
  float4 nodeU = nodeData[uint3(id.xy, id.z+1)];
  
  // Apply hydrostatic pressure
  float totalVelX = 0.0; float totalVelZ = 0.0;
  if (bottomNodeType == SOLID_NODE_TYPE || bottomNodeVol >= nodeVol) {
    totalVelX -= (nodeType(nodeL) == EMPTY_NODE_TYPE && 
      nodeVolume(nodeL) < nodeVol) ? dHSVel : 0;
    totalVelX += (nodeType(nodeR) == EMPTY_NODE_TYPE && 
      nodeVolume(nodeR) < nodeVol) ? dHSVel : 0;
    totalVelZ -= (nodeType(nodeD) == EMPTY_NODE_TYPE &&
      nodeVolume(nodeD) < nodeVol) ? dHSVel : 0;
    totalVelZ += (nodeType(nodeU) == EMPTY_NODE_TYPE &&
      nodeVolume(nodeU) < nodeVol) ? dHSVel : 0;
  }
  result.x = clamp(result.x + totalVelX, -maxPressureVel, maxPressureVel);
  result.z = clamp(result.z + totalVelZ, -maxPressureVel, maxPressureVel);

  // Friction hack
  float frictionVelX = dt*FRICTION_AMT;
  float frictionVelZ = dt*FRICTION_AMT;
  result.x = result.x < 0 ? min(0, result.x + frictionVelX) : max(0, result.x - frictionVelX);
  result.z = result.z < 0 ? min(0, result.z + frictionVelZ) : max(0, result.z - frictionVelZ);

  velApplExtForces[id.xyz] = result;
}

// Vorticity Confinement Kernels

//uint fullSize;
//float unitsPerNode;
//RWTexture3D<float4> vel;
RWTexture3D<float4> curl; // Output of CSCurl
RWTexture3D<float> curlLength; // Output of CSCurl

[numthreads(8,8,8)]
void CSCurl(uint3 id : SV_DispatchThreadID) {
  uint3 xyzm1 = uint3(clampm1(id.x), clampm1(id.y), clampm1(id.z)); 
  uint3 xyzp1 = uint3(clampp1(id.x, fullSize-1), clampp1(id.y, fullSize-1), clampp1(id.y, fullSize-1));

  float3 L = vel[uint3(xyzm1.x, id.y, id.z)].xyz;
  float3 R = vel[uint3(xyzp1.x, id.y, id.z)].xyz;
  float3 B = vel[uint3(id.x, xyzm1.y, id.z)].xyz;
  float3 T = vel[uint3(id.x, xyzp1.y, id.z)].xyz;
  float3 D = vel[uint3(id.x, id.y, xyzm1.z)].xyz;
  float3 U = vel[uint3(id.x, id.y, xyzp1.z)].xyz;

  float unitsPerNodeTimes2 = 2.0*unitsPerNode;
  float4 curlVec = float4(
    ((T[2] - B[2]) - (U[1] - D[1])) / unitsPerNodeTimes2,
    ((U[0] - D[0]) - (R[2] - L[2])) / unitsPerNodeTimes2,
    ((R[1] - L[1]) - (T[0] - B[0])) / unitsPerNodeTimes2, 0
  );

  curl[id.xyz] = curlVec;
  curlLength[id.xyz] = length(curlVec);
}

float dtVC;
//float unitsPerNode;
//RWTexture3D<float4> vel;
//RWTexture3D<float4> curl;
//RWTexture3D<float> curlLength;
RWTexture3D<float4> vcVel; // Output of CSVorticityConfinementKernel

[numthreads(8,8,8)]
void CSVorticityConfinementKernel(uint3 id : SV_DispatchThreadID) {
  uint3 xyzm1 = uint3(clampm1(id.x), clampm1(id.y), clampm1(id.z)); 
  uint3 xyzp1 = uint3(clampp1(id.x, fullSize-1), clampp1(id.y, fullSize-1), clampp1(id.y, fullSize-1));

  float4 omega = curl[id.xyz];
  float omegaL = curlLength[uint3(xyzm1.x, id.y, id.z)];
  float omegaR = curlLength[uint3(xyzp1.x, id.y, id.z)];
  float omegaB = curlLength[uint3(id.x, xyzm1.y, id.z)];
  float omegaT = curlLength[uint3(id.x, xyzp1.y, id.z)];
  float omegaD = curlLength[uint3(id.x, id.y, xyzm1.z)];
  float omegaU = curlLength[uint3(id.x, id.y, xyzp1.z)];

  float unitsPerNodeTimes2 = 2.0*unitsPerNode;
  float3 eta = float3(
    (omegaR - omegaL) / unitsPerNodeTimes2,
    (omegaT - omegaB) / unitsPerNodeTimes2, 
    (omegaU - omegaD) / unitsPerNodeTimes2
  );
  float etaLen = length(eta) + 1e-10;
  eta /= etaLen;
  float3 u = vel[id.xyz].xyz;

  vcVel[id.xyz] = float4(
    u[0] + dtVC * (eta[0]*omega[2] - eta[2]*omega[1]),
    u[1] + dtVC * (eta[2]*omega[0] - eta[0]*omega[2]),
    u[2] + dtVC * (eta[0]*omega[1] - eta[1]*omega[0]), 0
  );
}

